I"ÀM<h2 id="introduction">Introduction</h2>

<p>JSS can be used to create a headless omnichannel customer experience, that is reliable and easy to use. As a developer, JSS will enable you to build your websites using your favorite JavaScript framework (React, Angular, Vue) using any operating system.</p>

<h2 id="determine-methods-for-using-jss">Determine Methods for Using JSS</h2>

<h3 id="identify-types-of-cmss">Identify Types of CMSs</h3>

<p>The modern web content management system (CMS) is used for creating, managing, and optimizing your customers‚Äô digital experience. CMSs are generally the best way to organize and deliver content through a web service. There are three types of CMSs for you to identify in this track: traditional, headless, and Sitecore Omni‚Ñ¢.</p>

<p>A traditional CMS displays web content from a front-end delivery layer. This content is created in a front-end WYSIWYG editor such as Joomla! or WordPress and then saved to a back-end database.</p>

<p>A headless CMS decouples the CMS‚Äôs back-end content functions (e.g. creation, management, and storage) from front-end functions (e.g. presentation and delivery). This decoupling allows developers to render the content with different heads to serve the various content devices or applications (also known as channels). This multi-channel setup is also called the omnichannel. Examples of different channels include websites, mobile apps, and smartwatches.</p>

<p>Sitecore Omni is a headless CMS architecture that includes the easy editing ability found in a traditional CMS but uniquely offers personalization on any device or application. This approach is great for both back-end and front-end developers because the two roles can work in parallel.</p>

<p>For example, Sitecore developers can focus on applying their programming language expertise, while JavaScript developers can build the look, feel, and functionality of user experiences using the tools they know well (e.g. JavaScript libraries and frameworks). Developers can then push content out to any device or application using the latest APIs.</p>

<p>Sitecore has 5 offerings in its Omni Product family, described as:</p>

<ul>
  <li>
    <p>Sitecore GraphQL - an efficient front-end-driven query language that only returns a query‚Äôs requested data. Queries are graph traversal for expressive queries.</p>
  </li>
  <li>
    <p>Sitecore Services Client - offers industry standard services to access Sitecore content.</p>
  </li>
  <li>
    <p>Sitecore Experience Accelerator (SXA) - offers multiple options to deliver personalized, decoupled content management, delivery, and presentation via JSON.</p>
  </li>
  <li>
    <p>Universal Tracker - a scalable tracking service based on Web API technology.</p>
  </li>
  <li>
    <p>JavaScript Services (JSS) - a software development kit (SDK) that creates a seamless omnichannel customer experience in a headless CMS.</p>
  </li>
</ul>

<h3 id="explore-sitecore-jss-capabilities">Explore Sitecore JSS Capabilities</h3>

<p>Now that you can identify the the different types of CMSs, you will explore Sitecore JSS and its capabilities. JSS is a software development kit and one of the Sitecore Omni products you can use to create JavaScript applications, or apps, for a headless omnichannel customer experience. Any server running server-side JavaScript can host the apps. JSS offers several capabilities to front-end developers, including:</p>

<ul>
  <li>
    <p>Inline editing</p>
  </li>
  <li>
    <p>Multi-language</p>
  </li>
  <li>
    <p>Analytics</p>
  </li>
  <li>
    <p>Personalization</p>
  </li>
  <li>
    <p>Integrations</p>
  </li>
</ul>

<p>You can build apps with these types of capabilities independently or disconnected from Sitecore and by using your favorite JavaScript framework (Angular, React, or Vue). Once you deploy your app to Sitecore, you‚Äôll be able to manage the application in the Sitecore Experience Platform (XP) enterprise backend.</p>

<ul>
  <li>
    <p>Code-First Workflow - Use the code-first workflow to develop in your preferred OS, completely disconnected from Sitecore.</p>
  </li>
  <li>
    <p>Application Integration - With Sitecore‚Äôs application integration, JSS takes care of generating all necessary artifacts.</p>
  </li>
  <li>
    <p>Cross-Platform Support - The JSS SDK includes cross-platform support to deploy your app ‚Äòheadlessly‚Äô to any platform that runs server-side JavaScript.</p>
  </li>
  <li>
    <p>Ease of Use - The JSS SDK provides easy web app deployment and management as a nimble, self-contained JS bundle.</p>
  </li>
  <li>
    <p>Application Scalability - You can use CDNs, proxies, and a Node.js server to scale your applications.</p>
  </li>
  <li>
    <p>Headless Server-Side Rendering - You can use any service that supports hosting Node.js applications for headless server-side rendering.</p>
  </li>
</ul>

<p>To better understand how to implement the JSS capabilities, you‚Äôll want to be familiar with the four JSS features. Let‚Äôs take a closer look at this set of features and their functions.</p>

<ul>
  <li>
    <p>JSS Library - a series of npm packages that facilitate working with Sitecore data and presentation in JavaScript.</p>
  </li>
  <li>
    <p>Sitecore Layout Service - provides composition of pages and data needed for each component. In disconnected mode, the mock Layout Service emulates the data you would receive from the actual Sitecore Layout Service.</p>
  </li>
  <li>
    <p>JavaScript View Engine - allows Sitecore to perform server-side rendering of JavaScript applications.</p>
  </li>
  <li>
    <p>Application Import - allows you to apply a code-first approach.</p>
  </li>
</ul>

<h3 id="examine-the-code-first-approach">Examine the Code-First Approach</h3>

<p>Now that you know about the JSS capabilities and features that help front-end developers create JSS apps, you will examine how initial JSS app development can be done while disconnected from Sitecore, which is the code-first approach. The code-first approach allows developers to create and deploy apps in their preferred environment.</p>

<p><em>Code-First Details and Benefits</em></p>

<ul>
  <li>Designing with Code-First Workflow -</li>
</ul>

<p>Choose the code-first approach when:</p>

<ul>
  <li>
    <p>You need to design an early prototype.</p>
  </li>
  <li>
    <p>You do not have a Sitecore instance available to deploy to.</p>
  </li>
  <li>
    <p>You need to work on a non-Windows operating system.</p>
  </li>
  <li>
    <p>JavaScript developers are your primary designers.</p>
  </li>
  <li>
    <p>Your app will be relatively simple from a content perspective.</p>
  </li>
  <li>
    <p>You are hiring an external front-end agency to build your app.</p>
  </li>
</ul>

<p>The benefits of the code-first approach include:</p>

<ul>
  <li>
    <p>Being able to develop apps in your preferred OS.</p>
  </li>
  <li>
    <p>Being able to disconnect completely from Sitecore.</p>
  </li>
  <li>
    <p>Working with the JSS SDK without a Sitecore server install.</p>
  </li>
  <li>
    <p>Implementing UX Design Strategies - Consider a scenario where front-end JavaScript developers must work with UX designers to implement omnichannel UX wireframe designs. JSS is the perfect option to develop such designs because it can help ensure the required collaboration between UX and JavaScript designers. Such collaboration will provide the means to implement the essential elements of ‚Äúflexibility, exploration, and pre-decision timing.‚Äù</p>
  </li>
  <li>
    <p>Considering UX Designer Role - As a general practice, UX designers provide JavaScript developers with their wireframes in a visual representation tool such as Visio, OmniGraffle, or InDesign for very large projects. Alternatively, UX designers might provide JavaScript developers with an integrated or separate code approach for less complex sites or simple redesigns.</p>
  </li>
</ul>

<p>Either way, the designer and developer need to collaborate. This collaboration between them ensures they focus on the correct level of detail for the types of content and format in the site‚Äôs design.</p>

<ul>
  <li>Designing with No Limitations - Prior to JSS, creating rich Internet applications and creative sites was not easily done with the traditional Sitecore platform or Sitecore Experience Accelerator. However, now with JSS, a UX designer has no technical limitations. Their wireframes are not dependent on the JavasScript developer‚Äôs chosen framework or its available components.</li>
</ul>

<h2 id="build-a-jss-application-in-a-local-development-environment">Build a JSS Application in a Local Development Environment</h2>

<h3 id="identify-jss-requirements">Identify JSS Requirements</h3>

<p>Before you create an app, first make certain you meet the experience and Sitecore requirements discussed below. These requirements identify the necessary skills to use Sitecore JSS.</p>

<p><em>Experience Requirements</em></p>

<p>To create and build Sitecore JSS apps, you should have experience with the following applications to ensure you have the necessary skills:</p>

<ul>
  <li>
    <p>Modern JavaScript compiler</p>
  </li>
  <li>
    <p>JavaScript programming</p>
  </li>
  <li>
    <p>JSS-supported client framework (Angular, React, or Vue)</p>
  </li>
  <li>
    <p>Node JS</p>
  </li>
  <li>
    <p>YAML or JSON (to store route data in files)</p>
  </li>
</ul>

<p><em>Sitecore Requirements</em></p>

<p>In addition to having experience with the above applications, you also need to ensure you‚Äôve done the following:</p>

<ul>
  <li>
    <p>You‚Äôve completed the eLearning Sitecore Developer Foundations course OR</p>
  </li>
  <li>
    <p>You‚Äôre a Certified Sitecore Developer</p>
  </li>
</ul>

<h3 id="explore-the-jss-cli">Explore the JSS CLI</h3>

<p>Now that you understand the requirements, you are ready to set up a local development environment with the JSS command line interface (CLI) tool to create JSS apps. This track includes the following steps:</p>

<ol>
  <li>Explore the purpose of the JSS CLI</li>
</ol>

<p>Sitecore JSS includes the JSS CLI, which is a node-based command line tool with development scripts. The JSS CLI is the base tool for the code-first workflow. You use it to:</p>

<ul>
  <li>
    <p>Create, maintain, and run JavaScript apps.</p>
  </li>
  <li>
    <p>Scaffold components.</p>
  </li>
  <li>
    <p>Deploy apps to Sitecore.</p>
  </li>
</ul>

<p>To learn more about the JSS CLI and available scripts you can use, see <a href="https://jss-docs-preview3.herokuapp.com/docs/fundamentals/cli">JSS CLI Scripts</a>.</p>

<ol>
  <li>
    <p>Install and run the JSS CLI</p>
  </li>
  <li>
    <p>Install the JSS CLI with your command line tool of choice (e.g. bash, PowerShell, cmd prompt, or Node JS cmd prompt):</p>
  </li>
</ol>

<p><code class="highlighter-rouge">npm install -g @sitecore-jss/sitecore-jss-cli</code></p>

<p><em>Parts of the JSS CLI Command</em></p>

<p><code class="highlighter-rouge">npm</code> - Node Package Manager</p>

<p><code class="highlighter-rouge">install</code> - Install command</p>

<p><code class="highlighter-rouge">-g</code> - Flag that enables the jss command to run from any directory (global)</p>

<p><code class="highlighter-rouge">@sitecore-jss/sitecore-jss-cli</code> - Package name of the JSS CLI</p>

<ol>
  <li>To verify that your CLI installation was successful, enter the command:</li>
</ol>

<p><code class="highlighter-rouge">jss --help</code></p>

<p>The <code class="highlighter-rouge">jss</code> commands change when running within a JSS apps‚Äô directory. The <code class="highlighter-rouge">--help</code> option will always show the currently available commands.</p>

<h3 id="create-a-jss-application">Create a JSS Application</h3>

<p>Now that you have the JSS CLI installed, you are ready to create your sample JSS app.</p>

<p><em>Steps to Create Sample JSS App</em></p>

<ol>
  <li>Identify Framework Options</li>
</ol>

<p>With the JSS CLI installed, you are now ready to create applications. The first step is to identify the template that matches your framework (Angular, React, or Vue).</p>

<p>Each sample app includes the mocked Sitecore Layout Service so you can develop without the need to connect to a Sitecore installation.</p>

<ul>
  <li>
    <p>Go to <a href="https://github.com/Sitecore/jss/tree/master/samples/">GITHUB TEMPLATES</a> to locate sample apps with the code for each template.</p>
  </li>
  <li>
    <p>Go to <a href="https://jss.sitecore.com/docs/getting-started/quick-start#step-3-choose-a-jss-application-template">TEMPLATE INFO</a> to learn more about template options.</p>
  </li>
</ul>

<ol>
  <li>Create a Sample Application</li>
</ol>

<ul>
  <li>
    <p>Open a command prompt.</p>
  </li>
  <li>
    <p>Type the create app command for your framework/library in the form:
<code class="highlighter-rouge">jss create &lt;your-app-name&gt; &lt;app-template-name&gt;</code></p>
  </li>
</ul>

<p>For example:
<code class="highlighter-rouge">jss create my-first-jss-app angular</code>
<code class="highlighter-rouge">jss create my-first-jss-app react</code>
<code class="highlighter-rouge">jss create my-first-jss-app vue</code></p>

<ul>
  <li>
    <p>Change to your app‚Äôs directory. For example:
<code class="highlighter-rouge">cd my-first-jss-app</code></p>
  </li>
  <li>
    <p>Type the command to start the app in disconnected mode (which uses the defined content located on the local development server):
<code class="highlighter-rouge">jss start</code></p>
  </li>
</ul>

<ol>
  <li>Inspect the App Viewer Feature</li>
</ol>

<p>The app viewer is a local webpack-dev-server feature to view your app in a browser without importing any items to Sitecore. After the JSS start command runs, this feature automatically launches your app in the default browser, http://localhost:3000.</p>

<p>This app includes a website with all the JSS resources you need to develop your site without publishing them first. Resource items include different dates, time, languages, multiple device view settings, and more.</p>

<h2 id="create-jss-routes-to-host-components-and-their-data">Create JSS Routes to Host Components and Their Data</h2>

<h3 id="maintain-app-directories">Maintain App Directories</h3>

<p>Now that you know how to create a JSS app, you need to understand routes. The first step in understanding routes is to examine how the JSS app directory structure works. Understanding the app directory will be important when you customize your apps with new routes from templates to host components and their data.</p>

<p>To maintain your site‚Äôs directory structure, you will use various tools that are described below.</p>

<ul>
  <li>
    <p>npm / Node JS - JSS SDK includes a series of npm packages that facilitate working with Sitecore data and layouts in JavaScript. Use Node JS to create one parent or master folder that will contain each individual JSS project. Use npm to create a JSS project with the proper folder structure.</p>
  </li>
  <li>
    <p>Visual Studio Code - Visual Studio Code is a source code text editor that supports hundreds of languages, syntax highlighting, bracket-matching, auto-indentation, box-selection, JS typings, snippets, and other components. Use Visual Studio Code to maintain site content, route (layout) data, and component registrations.</p>
  </li>
  <li>
    <p>Framework-specific SDKs - Framework-specific SDKs provide Sitecore‚Äôs dynamic placeholder layout system and helpers. Use these to render Sitecore fields so they can be editable by Sitecore authors.</p>
  </li>
</ul>

<p>The following five topics will help you learn how to use the tools described above to maintain your app directories. Each topic includes examples that demonstrate using or applying these tools.</p>

<ol>
  <li>An app‚Äôs project folder in Explorer</li>
</ol>

<p>Visual Studio Code‚Äôs Explorer window lists the following folders created by the JSS CLI when you made your app:</p>

<ul>
  <li>
    <p>A node modules folder stores all your JavaScript libraries and commands to support multiple apps with different JSS versions</p>
  </li>
  <li>
    <p>A config file generates the site definition for the route items and the database</p>
  </li>
</ul>

<ol>
  <li>An app‚Äôs project folder in a CLI</li>
</ol>

<p>You can also view your site contents in PowerShell / Terminal.</p>

<ol>
  <li>From Visual Studio Code‚Äôs Explorer window, you should:</li>
</ol>

<ul>
  <li>
    <p>Locate your master folder</p>
  </li>
  <li>
    <p>Press the Control and Minus keys <code class="highlighter-rouge">Ctrl + -</code> anywhere</p>
  </li>
  <li>
    <p>Select <code class="highlighter-rouge">Open in Terminal</code></p>
  </li>
</ul>

<p>You‚Äôll automatically be in the Master Folder directory.</p>

<ol>
  <li>
    <p>From PowerShell / Terminal, you can ensure the <code class="highlighter-rouge">PATH</code> environment variable lists the global <code class="highlighter-rouge">npm cachefolder</code>. 
Type the command:
<code class="highlighter-rouge">npm ‚Äìversion</code></p>
  </li>
  <li>
    <p>The role of the manifest API</p>
  </li>
</ol>

<p>The JSS app is a repository structure. In disconnected mode, use the manifest application programming interface (API) to do the following:</p>

<ul>
  <li>
    <p>Define the structure of your JSS site</p>
  </li>
  <li>
    <p>Run the site with mock data</p>
  </li>
  <li>
    <p>Import the site into Sitecore</p>
  </li>
</ul>

<p>To see the list of available manifest objects, see <a href="https://jss.sitecore.com/docs/techniques/working-disconnected/manifest-api#manifest-objects">Manifest Objects</a>.</p>

<ol>
  <li>Directory organization</li>
</ol>

<p>The way you organize a site correlates with your content needs. In disconnected mode, the manifest API creates a manifest of the JSS app‚Äôs content. With respect to this content, the manifest does the following:</p>

<ul>
  <li>
    <p>Includes content data and data schema with both components and routes from a set of files;</p>
  </li>
  <li>
    <p>Enables the JSS app to execute with local mock content, without a Sitecore instance</p>
  </li>
  <li>
    <p>Assigns the JSS app as the master copy of all artifacts</p>
  </li>
</ul>

<ol>
  <li>An app‚Äôs main directory elements</li>
</ol>

<p>There are three types of directory items specific to Sitecore terminology you‚Äôll want to know: arbitrary content, routes, and components. Continue below to look at each one in more detail.</p>

<p><em>Arbitrary Content:</em></p>

<ul>
  <li>
    <p>They are not used as pages or datasources</p>
  </li>
  <li>
    <p>They are referred to as ‚Äúlookups‚Äù or ‚Äúlist items‚Äù</p>
  </li>
  <li>
    <p>They cannot be viewed directly in browsers because they don‚Äôt have any layout data</p>
  </li>
  <li>
    <p>They are usually used for restricting values of route-level or component-level fields to a limited set of options such as sharing content across routes (e.g. an author‚Äôs bio)</p>
  </li>
</ul>

<p><em>Routes:</em></p>

<ul>
  <li>
    <p>These items are ‚Äúpages‚Äù since they can be viewed in browsers using unique URLs. They contain route-level fields and instructions for how to lay out the route‚Äôs components</p>
  </li>
  <li>
    <p>Site implementations may need multiple route types to capture route-level fields. Examples include article route, product route, and location route. In Sitecore terminology, route types are ‚Äútemplates‚Äù</p>
  </li>
</ul>

<p><em>Components:</em></p>

<ul>
  <li>
    <p>These are ‚Äúrendering datasources,‚Äù where a datasource is comprised of a component name plus its field</p>
  </li>
  <li>
    <p>They contain component-level fields. These items cannot be viewed in browsers directly because they don‚Äôt have any layout data; they are simply building blocks for route presentation</p>
  </li>
</ul>
:ET